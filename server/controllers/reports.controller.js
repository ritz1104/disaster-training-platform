// server/controllers/reports.controller.js
const Training = require('../models/training.model');
const PDFDocument = require('pdfkit');
const csvWriter = require('csv-writer');
const fs = require('fs');
const path = require('path');

// @desc    Generate PDF report
// @route   GET /api/reports/pdf
// @access  Private (Admin)
const generatePDFReport = async (req, res) => {
  try {
    const { startDate, endDate, state, theme, reportType = 'summary' } = req.query;

    // Build query
    let matchQuery = {};
    if (startDate || endDate) {
      matchQuery.date = {};
      if (startDate) matchQuery.date.$gte = new Date(startDate);
      if (endDate) matchQuery.date.$lte = new Date(endDate);
    }
    if (state) matchQuery.state = state;
    if (theme) matchQuery.theme = theme;

    // Fetch data based on report type
    let reportData;
    if (reportType === 'detailed') {
      reportData = await Training.find(matchQuery)
        .populate('organizer', 'name organization')
        .sort({ date: -1 })
        .lean();
    } else {
      // Summary report
      reportData = await Training.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: '$state',
            totalTrainings: { $sum: 1 },
            totalParticipants: { $sum: '$participants.actual' },
            themes: { $addToSet: '$theme' }
          }
        },
        { $sort: { totalTrainings: -1 } }
      ]);
    }

    // Create PDF document
    const doc = new PDFDocument({ margin: 50 });
    
    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="ndma-training-report-${Date.now()}.pdf"`);
    
    // Pipe the PDF to the response
    doc.pipe(res);

    // Add header
    doc.fontSize(20).text('NDMA Training Monitor Report', { align: 'center' });
    doc.fontSize(12).text('National Disaster Management Authority', { align: 'center' });
    doc.moveDown();

    // Add report metadata
    doc.fontSize(10);
    doc.text(`Report Generated: ${new Date().toLocaleString()}`);
    doc.text(`Report Type: ${reportType.charAt(0).toUpperCase() + reportType.slice(1)}`);
    if (startDate) doc.text(`Start Date: ${new Date(startDate).toLocaleDateString()}`);
    if (endDate) doc.text(`End Date: ${new Date(endDate).toLocaleDateString()}`);
    if (state) doc.text(`State: ${state}`);
    if (theme) doc.text(`Theme: ${theme}`);
    doc.moveDown();

    // Add content based on report type
    if (reportType === 'detailed' && reportData.length > 0) {
      doc.fontSize(14).text('Training Details', { underline: true });
      doc.moveDown();

      reportData.forEach((training, index) => {
        if (doc.y > 700) doc.addPage(); // Add new page if needed

        doc.fontSize(10);
        doc.text(`${index + 1}. ${training.title}`);
        doc.text(`   Date: ${new Date(training.date).toLocaleDateString()}`);
        doc.text(`   Location: ${training.location.address}, ${training.district}, ${training.state}`);
        doc.text(`   Theme: ${training.theme}`);
        doc.text(`   Trainer: ${training.trainer.name} (${training.trainer.organization || 'N/A'})`);
        doc.text(`   Participants: Planned: ${training.participants.planned}, Actual: ${training.participants.actual}`);
        doc.text(`   Duration: ${training.duration.hours} hours`);
        doc.text(`   Status: ${training.status}`);
        doc.moveDown(0.5);
      });
    } else {
      // Summary report
      doc.fontSize(14).text('Training Summary by State', { underline: true });
      doc.moveDown();

      let totalTrainings = 0;
      let totalParticipants = 0;

      reportData.forEach((stateData) => {
        doc.fontSize(10);
        doc.text(`${stateData._id}: ${stateData.totalTrainings} trainings, ${stateData.totalParticipants} participants`);
        totalTrainings += stateData.totalTrainings;
        totalParticipants += stateData.totalParticipants;
      });

      doc.moveDown();
      doc.fontSize(12).text(`Total Trainings: ${totalTrainings}`);
      doc.text(`Total Participants: ${totalParticipants}`);
    }

    // Add footer
    doc.fontSize(8);
    doc.y = doc.page.height - 50;
    doc.text('Generated by NDMA Training Monitor System', { align: 'center' });

    doc.end();

  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating PDF report',
      error: error.message
    });
  }
};

// @desc    Generate CSV report
// @route   GET /api/reports/csv
// @access  Private (Admin)
const generateCSVReport = async (req, res) => {
  try {
    const { startDate, endDate, state, theme, format = 'detailed' } = req.query;

    // Build query
    let matchQuery = {};
    if (startDate || endDate) {
      matchQuery.date = {};
      if (startDate) matchQuery.date.$gte = new Date(startDate);
      if (endDate) matchQuery.date.$lte = new Date(endDate);
    }
    if (state) matchQuery.state = state;
    if (theme) matchQuery.theme = theme;

    // Fetch training data
    const trainings = await Training.find(matchQuery)
      .populate('organizer', 'name email organization')
      .sort({ date: -1 })
      .lean();

    // Create temporary file
    const fileName = `ndma-training-report-${Date.now()}.csv`;
    const filePath = path.join(__dirname, '../temp', fileName);

    // Ensure temp directory exists
    const tempDir = path.dirname(filePath);
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    // Define CSV headers based on format
    let headers, records;

    if (format === 'summary') {
      // Summary format - aggregated data
      const summaryData = await Training.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: {
              state: '$state',
              theme: '$theme'
            },
            totalTrainings: { $sum: 1 },
            totalParticipants: { $sum: '$participants.actual' },
            avgDuration: { $avg: '$duration.hours' }
          }
        }
      ]);

      headers = [
        { id: 'state', title: 'State' },
        { id: 'theme', title: 'Theme' },
        { id: 'totalTrainings', title: 'Total Trainings' },
        { id: 'totalParticipants', title: 'Total Participants' },
        { id: 'avgDuration', title: 'Average Duration (Hours)' }
      ];

      records = summaryData.map(item => ({
        state: item._id.state,
        theme: item._id.theme,
        totalTrainings: item.totalTrainings,
        totalParticipants: item.totalParticipants,
        avgDuration: Math.round(item.avgDuration * 100) / 100
      }));

    } else {
      // Detailed format - individual training records
      headers = [
        { id: 'title', title: 'Training Title' },
        { id: 'date', title: 'Date' },
        { id: 'state', title: 'State' },
        { id: 'district', title: 'District' },
        { id: 'theme', title: 'Theme' },
        { id: 'trainingType', title: 'Training Type' },
        { id: 'targetAudience', title: 'Target Audience' },
        { id: 'trainerName', title: 'Trainer Name' },
        { id: 'trainerOrg', title: 'Trainer Organization' },
        { id: 'plannedParticipants', title: 'Planned Participants' },
        { id: 'actualParticipants', title: 'Actual Participants' },
        { id: 'maleParticipants', title: 'Male Participants' },
        { id: 'femaleParticipants', title: 'Female Participants' },
        { id: 'duration', title: 'Duration (Hours)' },
        { id: 'status', title: 'Status' },
        { id: 'address', title: 'Address' },
        { id: 'organizer', title: 'Organizer' },
        { id: 'organizerOrg', title: 'Organizer Organization' }
      ];

      records = trainings.map(training => ({
        title: training.title,
        date: new Date(training.date).toLocaleDateString(),
        state: training.state,
        district: training.district,
        theme: training.theme,
        trainingType: training.trainingType,
        targetAudience: training.targetAudience,
        trainerName: training.trainer.name,
        trainerOrg: training.trainer.organization || '',
        plannedParticipants: training.participants.planned,
        actualParticipants: training.participants.actual,
        maleParticipants: training.participants.male,
        femaleParticipants: training.participants.female,
        duration: training.duration.hours,
        status: training.status,
        address: training.location.address,
        organizer: training.organizer?.name || '',
        organizerOrg: training.organizer?.organization || ''
      }));
    }

    // Create CSV writer
    const writer = csvWriter.createObjectCsvWriter({
      path: filePath,
      header: headers
    });

    // Write CSV file
    await writer.writeRecords(records);

    // Send file as download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);

    // Clean up temp file after sending
    fileStream.on('end', () => {
      fs.unlink(filePath, (err) => {
        if (err) console.error('Error deleting temp file:', err);
      });
    });

  } catch (error) {
    console.error('CSV generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Error generating CSV report',
      error: error.message
    });
  }
};

// @desc    Get report statistics
// @route   GET /api/reports/stats
// @access  Private (Admin)
const getReportStats = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    let matchQuery = {};
    if (startDate || endDate) {
      matchQuery.date = {};
      if (startDate) matchQuery.date.$gte = new Date(startDate);
      if (endDate) matchQuery.date.$lte = new Date(endDate);
    }

    const stats = await Training.aggregate([
      { $match: matchQuery },
      {
        $group: {
          _id: null,
          totalRecords: { $sum: 1 },
          totalParticipants: { $sum: '$participants.actual' },
          uniqueStates: { $addToSet: '$state' },
          uniqueThemes: { $addToSet: '$theme' },
          dateRange: {
            $push: '$date'
          }
        }
      },
      {
        $project: {
          totalRecords: 1,
          totalParticipants: 1,
          uniqueStatesCount: { $size: '$uniqueStates' },
          uniqueThemesCount: { $size: '$uniqueThemes' },
          earliestDate: { $min: '$dateRange' },
          latestDate: { $max: '$dateRange' }
        }
      }
    ]);

    res.status(200).json({
      success: true,
      data: stats[0] || {
        totalRecords: 0,
        totalParticipants: 0,
        uniqueStatesCount: 0,
        uniqueThemesCount: 0,
        earliestDate: null,
        latestDate: null
      }
    });

  } catch (error) {
    console.error('Report stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching report statistics',
      error: error.message
    });
  }
};

module.exports = {
  generatePDFReport,
  generateCSVReport,
  getReportStats
};